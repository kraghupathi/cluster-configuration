#+Title: Lab Role
#+Date: August 13, 2015. Thursday
#+PROPERTY: session *scratch*
#+PROPERTY: results output
#+PROPERTY: exports code
#+OPTIONS: ^:nil

* Introduction
  As labs are part of the clusters they need to conform to the general
  security guidelines. This model describes such configuration of a
  lab node.

* Requirements

** Assumptions
   - It is assumed that lab nodes are running Debian/Ubuntu

** Functional Requirements

*** Which ADS applies
   1) Set default gateway as router

*** Requirements applied by lab role
   1) Save history of executed command with time stamp
   2) Start iptables service
   3) Permit root login without password
   4) Install bind utilities
   5) Remove sudoers package

*** Security Requirements
   1) Secure server from various attacks such as brute-force
   3) Disable password based SSH access
   4) Enable key based SSH authentication
   5) Do not permit empty password for SSH logins
   6) Lock root account
   7) Restrict TCP port 9089 on lab to ADS IP address

* Implementation
** Layout of scripts
** Firewall rules
   This node has the same firewall rules as explained in [[file://common.org::*Common%20Firewall%20Rules][Common
   firewall rules]]. The exception for Security Requirement 7, which
   restricts access to TCP port 9089 to ADS node.
   
#+BEGIN_EXAMPLE
iptables -I INPUT -s <ADS_IP_here> -m tcp -p tcp --dport 9089 -j ACCEPT
#+END_EXAMPLE

#+BEGIN_SRC yml -n :tangle roles/lab_role/templates/lab_iptables :eval no
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]

#Accept loopback connections
-A INPUT -i lo -d 127.0.0.0/8 -j ACCEPT

#Rate limit new connections to 20 new connections per 30 seconds
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --set
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --rcheck --seconds 30 --hitcount 20 -m limit --limit 2/min -j LOG --log-prefix "new_limit_"
-A INPUT ! -p udp -m state --state NEW -m recent --name ssh_limit --rcheck --seconds 30 --hitcount 20 -j DROP

#Accept ICMP ping requests at limited rate
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 60/minute --limit-burst 120 -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/minute --limit-burst 2 -j LOG
-A INPUT -p icmp --icmp-type echo-request -j DROP

#Allow ongoing connections
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

#Allow incoming connection from ADS on TCP port 9098
-A INPUT -s {{ads_ip}} -m tcp -p tcp --dport 9098

#Allow incoming SSH connections from ansible server IPs.  Hopefully fail2ban will take care of bruteforce attacks from ansible server IPs
{% for item in ansible_server_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}

#Allow incoming NRPE queries for nagios from nagios servers
-A INPUT -m state --state NEW -p tcp -m tcp --dport 5666 -j ACCEPT

#Allow SNMP queries from cacti servers
-A INPUT -p udp -m udp --dport 161 -j ACCEPT
-A INPUT -p udp -m udp --dport 162 -j ACCEPT

#Log all other "blocked_input_" attempts with rate limiting
-A INPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_input_"

#Drop all other input packets
-A INPUT -j DROP

#Disable packet forwarding 
-A FORWARD -j DROP

##Output rules
#Allow outgoing connections to localhost
-A OUTPUT -s 127.0.0.0/8 -o lo -j ACCEPT

#Allow outgoing connections to ansible server on port22
{% for item in ansible_server_ips  %}
-A OUTPUT -d {{item}} -p tcp -m tcp --sport 22 -j ACCEPT
{% endfor %}

#Allow ongoing connections
-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

#Allow SSH
-A OUTPUT -p tcp -m tcp --dport 22 -j ACCEPT

#Allow server to send emails.  Required for sending logwatch emails
-A OUTPUT -p tcp -m tcp --dport 25 -j ACCEPT

#Allow https/http
-A OUTPUT -p tcp -m tcp --dport 443 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPT

#Allow to make DNS queries
-A OUTPUT -p udp -m udp --dport 53 -j ACCEPT

#Allow outgoing ping requests
-A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT

#Allow outgoing connections to rsyslog server
-A OUTPUT -p udp -m udp --dport 514 -j ACCEPT

#Allow outgoing connections to OSSEC server
-A OUTPUT -p udp -m udp --dport 1514 -j ACCEPT

#Log all other "blocked_output_" attempts
-A OUTPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_output_"

#Reply with proper ICMP error message and reject the connection
-A OUTPUT -j REJECT --reject-with icmp-host-prohibited

COMMIT
#
#+END_SRC
** Tasks
*** Block brute force attempts
   Nodes in the cluster are protected against Brute-force attacks. For
   this *Fail2ban* service is configured on all the nodes. It bans an
   offensive host by adding rule in firewall and also sends an email
   alerts to the system administrator. When the firewall rule for
   offensive host is added, the attacker can not connect to the
   cluster for a limited period of time.

   To configure Fail2ban following actions are performed:
   1) Install epel repo
   2) Install fail2ban
   3) Start fail2ban service

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
---

#Install fail2ban and enable it on startup
- name: Install fail2ban
  apt: name=fail2ban state=present

- name: Start and enable fail2ban service
  service: name=fail2ban state=started enabled=yes
#+END_SRC

*** Save History of Executed Commands
   Commands executed on the servers are logged with the time
   stamp. These logged commands can be referred by the system
   administrator to trouble shoot any issues on the server.

   To save history of commands a shell script is created and placed
   inside =/etc/profile.d= directory. Scripts present inside the
   =/etc/profile.d= directory gets executed at the start of every new
   session.

   Following history parameters are set:

    - HISTTIMEFORMAT :: sets the time format of time stamp
    - HISTSIZE       :: sets the number of lines or commands that are
                        stored in memory in a history list while bash
                        session is ongoing
    - HISTFILESIZE   :: sets the number of lines or commands that are allowed in
                        the history file at start up time of a session, and are
                        stored in the history file at the end of bash session
                        for use in future sessions.

#+BEGIN_SRC shell :tangle roles/lab_role/files/history.sh
#!/bin/bash

HISTTIMEFORMAT="%y %m %d %T"
HISTSIZE=100000
HISTFILESIZE=100000
export HISTTIMEFORMAT HISTSIZE HISTFILESIZE
#+END_SRC

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
#Configure history
- name: Configure history for all users with date/time and 100,000 lines of history
  copy: src=history.sh dest=/etc/profile.d/history.sh mode=755 owner=root group=root
#+END_SRC 

*** Start iptables service
   While setting up the cluster, iptables service is restarted on all
   the servers - to make sure the service is running inside each
   server. If anyone inserts a temporary or adhoc rule using terminal
   commands such as =iptables -A INPUT -p tcp --dport 80 -j ACCEPT=,
   the rules will not be saved in the file. These rules we assume are
   not necessary for the system, so restarting "iptables" will remove
   these inserted rules.

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml

- name: Copy iptables template
  template: src= lab_iptables dest=/etc/iptables.ruleset owner=root group=root

- name: apply iptables rules
  shell: iptables-restore << /etc/iptables.ruleset

#+END_SRC

*** Setup /etc/hosts file
   Sendmail tries to lookup hostname and IP mapping through
   =/etc/hosts=. Sendmail assumes the first line in =/etc/hosts= is
   the nodes own FQDN to IP mapping without this sendmail takes about
   30 seconds to timeout for host resolution. To take care of this
   assumption of sendmail =/etc/hosts= file is configured.

   Following variables are set by the ansible playbook scripts as it
   runs on the client node. For each server in the cluster value of
   these variables will be different and set according to the server
   role.

|-------+------------------------------+-------------------------------+--------------------------|
| S.no. | Variable Name                | Description                   | Example                  |
|-------+------------------------------+-------------------------------+--------------------------|
|    1. | ansible_default_ipv4.address | defines the system ip address | 10.1.100.8               |
|-------+------------------------------+-------------------------------+--------------------------|
|    2. | ansible_fqdn                 | define the system fqdn        | ossec.virtual-labs.ac.in |
|-------+------------------------------+-------------------------------+--------------------------|
|    3. | ansible_hostname             | defines the system hostnames  | ossec                    |
|-------+------------------------------+-------------------------------+--------------------------|

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
#Setup /etc/hosts
- name: Configure hostname and fqdn to resolve to local IP on first line of /etc/hosts
#Necessary for containers so that they can send emails without 30 second delay
  lineinfile: dest=/etc/hosts regexp="{{ansible_default_ipv4.address}} {{ansible_fqdn}} {{ansible_hostname}}" insertbefore="BOF" line="{{ansible_default_ipv4.address}} {{ansible_fqdn}} {{ansible_hostname}}"
#+END_SRC

*** Set Name Resolver
   Nameservers are set on all the servers in the cluster. An example
   of configuration file - =/etc/resolv.conf= is shown and described
   below:

#+BEGIN_EXAMPLE
search localdomain.com
nameserver 10.4.12.230
#+END_EXAMPLE

   - search :: This field allows users to type simple names instead of
               complete 'fqdn' to reach local resources. If something
               comes to resolver that has no dots '.' in it, the
               resolver will try adding =localdomain.com= in it.
   - nameserver :: This field specifies the ip address of the dns
                   servers.

   Ansible jinja2 template is copied to the all nodes from the
   configuration server node.

#+BEGIN_SRC conf :tangle roles/lab_role/templates/resolv.conf
{% if private_dns_zone != "none" %}
search {{private_dns_zone}}
{% endif %}
{% for private_dns in private_dns_ips %}
nameserver {{private_dns}}
{% endfor %}
#+END_SRC


*** COMMENT SSH Hardening
   All the servers in the cluster are made secure by hardening *ssh*
   service. SSH configuration file =/etc/ssh/sshd_config= is
   customized as per the requirement.

**** Permit Root Login without password
   Only system administrators with ssh private key can login as Root.

#+BEGIN_EXAMPLE
#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: Permit root login without-password(key based)
  lineinfile: dest=/etc/ssh/sshd_config regexp='PermitRootLogin ' line='PermitRootLogin without-password' state=present
#+END_SRC
#+END_EXAMPLE

**** Disable Password based access
   Password based access is disabled.
#+BEGIN_EXAMPLE
#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: Disable Password authentication
  lineinfile: dest=/etc/ssh/sshd_config regexp='PasswordAuthentication ' line='PasswordAuthentication no'
#+END_SRC
#+END_EXAMPLE

**** Enable Key based authentication
   Only key based access is enabled.
#+BEGIN_EXAMPLE
#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: Enable Public key authentication
  lineinfile: dest=/etc/ssh/sshd_config regexp='PubkeyAuthentication ' line='PubkeyAuthentication yes'
#+END_SRC
#+END_EXAMPLE

**** Do not permit empty passwords
   Users are not allowed to set empty-password.
#+BEGIN_EXAMPLE
#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: Do not permit empty password, also ensure proper owner, group and permissions
  lineinfile: dest=/etc/ssh/sshd_config regexp='PermitEmptyPasswords ' line='PermitEmptyPasswords no' mode=0600 owner=root group=root

#Call handler to restart sshd
  notify:
      - restart ssh
#+END_SRC
#+END_EXAMPLE

*** COMMENT Disable Root Login
   Root login is disabled on all the servers in the cluster. Password
   for the root account is set to a value which matches no possible
   encrypted value, therefore nobody can login as root with
   password. Only system administrators with ssh private keys can
   login to root account.

**** Lock root login
   Root account is locked using =passwd= command command in the
   terminal.  Another way to lock account is to replace the root's
   encrypted password with '!' in =/etc/shadow= file as follows.

#+BEGIN_EXAMPLE
root:!:12345::::::
#+END_EXAMPLE

#+BEGIN_EXAMPLE
#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: lock root account
  shell: passwd -l root
#+END_SRC
#+END_EXAMPLE

**** Enable root login
   Root login can be enabled by setting the root password using
   following command
#+BEGIN_EXAMPLE
sudo passwd root
#+END_EXAMPLE

**** Unlock root account
   Root login can be unlocked using following command.
#+BEGIN_EXAMPLE
sudo passwd -u root
#+END_EXAMPLE


*** Set the implementation/model release
   Release number is set in all the nodes in the cluster. Release
   number describes the version of the configuration applied on the
   node.

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: setting the implementation/model release
  lineinfile: dest=/etc/motd regexp="^Release" line="Release number {{ release_no }}" state=present create=yes
  ignore_errors: yes
#+END_SRC

*** Common Variables
   Variables which are common across all the ansible roles are defined
   in =common_vars= file. The file is included as a dependency for
   this role.

#+BEGIN_SRC yml :tangle roles/lab_role/meta/main.yml
---
dependencies:
  - role: common_vars
#+END_SRC


** Handlers
   When any changes are made in the configuration file of any service, the
   service needs to be restarted. For example, if modifications are made in
   sendmail configuration file to customize sendmail service, then the sendmail
   service needs to be restarted to enforce the modified properties of the
   system.

#+BEGIN_SRC yml :tangle roles/lab_role/handlers/main.yml
---
- name: restart SSH
  service: name=ssh state=restarted
#+END_SRC

* Test Cases
