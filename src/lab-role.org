#+Title: Lab Role
#+Date: August 13, 2015. Thursday
#+PROPERTY: session *scratch*
#+PROPERTY: results output
#+PROPERTY: exports code
#+OPTIONS: ^:nil

* Introduction
  As labs are part of the clusters they need to conform to the general
  security guidelines. This model describes such configuration of a
  lab node.

* Requirements

** Assumptions
   - It is assumed that lab nodes are running Debian/Ubuntu
   - This role is intended to harden the node, things like firewall,
     SSH, and hence will not add or remove any packages or services,
     this is because ADS will configure the node.

** Functional Requirements

*** Which ADS applies
   1) Set default gateway as router

*** Requirements applied by lab role
   1) Save history of executed command with time stamp
   2) Apply firewall rules
   3) Permit root login without password
   4) Remove sudoers package

*** Security Requirements
   1) Secure server from various attacks such as brute-force
   3) Disable password based SSH access
   4) Enable key based SSH authentication
   5) Do not permit empty password for SSH logins
   6) Lock root account
   7) Restrict TCP port 9089 on lab to ADS IP address

* Design
** Network Digram
   The following diagram represents lab node in the network, please
   note some monitoring services like Nagios, Cacti, are not shown.
   
   #+CAPTION: Lab node in the cluster
   #+LABEL: Lab node
   [[./diagrams/lab-role.png][Lab node]]

** Source of network diagram
   Following is the downloadable source file used to create the above
   diagram, needs Libreoffice and VRT extensions.

   [[./diagrams/lab-role.odg][Lab_role]]
* Implementation
** Firewall rules
   This node has the same firewall rules as explained in [[file:common.org::*Common%20Firewall%20Rules][Common
   firewall rules]]. The exception is for Security Requirement 7, which
   restricts access to TCP port 9089 allowing only ADS node.
   
#+BEGIN_EXAMPLE
iptables -I INPUT -s <ADS_IP_here> -m tcp -p tcp --dport 9089 -j ACCEPT
#+END_EXAMPLE

#+BEGIN_SRC yml -n :tangle roles/lab_role/templates/lab_iptables :eval no
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]

#Accept loopback connections
-A INPUT -i lo -d 127.0.0.0/8 -j ACCEPT

#Rate limit new connections to 20 new connections per 30 seconds
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --set
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --rcheck --seconds 30 --hitcount 20 -m limit --limit 2/min -j LOG --log-prefix "new_limit_"
-A INPUT ! -p udp -m state --state NEW -m recent --name ssh_limit --rcheck --seconds 30 --hitcount 20 -j DROP

#Accept ICMP ping requests at limited rate
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 60/minute --limit-burst 120 -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/minute --limit-burst 2 -j LOG
-A INPUT -p icmp --icmp-type echo-request -j DROP

#Allow ongoing connections
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

#Allow incoming connection from ADS on TCP port 9098
-A INPUT -s {{ads_ip}} -m tcp -p tcp -m state --state NEW --dport 9098 -j ACCEPT

#Allow incoming SSH connections from ansible server IPs.  Hopefully fail2ban will take care of bruteforce attacks from ansible server IPs
{% for item in ansible_server_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}

#Allow incoming SSH connections from ADS node
-A INPUT -m state --state NEW -s {{ads_ip}} -p tcp -m tcp --dport 22 -j ACCEPT

#Allow incoming NRPE queries for nagios from nagios servers
-A INPUT -m state --state NEW -p tcp -m tcp --dport 5666 -j ACCEPT

#Allow SNMP queries from cacti servers
-A INPUT -p udp -m udp --dport 161 -j ACCEPT
-A INPUT -p udp -m udp --dport 162 -j ACCEPT

#Allow TCP 80, 443 access from anywhere
-A INPUT -m tcp -p tcp --dport 80 -j ACCEPT
-A INPUT -m tcp -p tcp --dport 443 -j ACCEPT

#Log all other "blocked_input_" attempts with rate limiting
-A INPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_input_"

#Drop all other input packets
-A INPUT -j DROP

#Disable packet forwarding 
-A FORWARD -j DROP

##Output rules
#Allow outgoing connections to localhost
-A OUTPUT -s 127.0.0.0/8 -o lo -j ACCEPT

#Allow outgoing connections to ansible server on port22
{% for item in ansible_server_ips  %}
-A OUTPUT -d {{item}} -p tcp -m tcp --sport 22 -j ACCEPT
{% endfor %}

#Allow ongoing connections
-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

#Allow SSH
-A OUTPUT -p tcp -m tcp --dport 22 -j ACCEPT

#Allow server to send emails.  Required for sending logwatch emails
-A OUTPUT -p tcp -m tcp --dport 25 -j ACCEPT

#Allow https/http
-A OUTPUT -p tcp -m tcp --dport 443 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPT

#Allow to make DNS queries
-A OUTPUT -p udp -m udp --dport 53 -j ACCEPT

#Allow outgoing ping requests
-A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT

#Allow outgoing connections to rsyslog server
-A OUTPUT -p udp -m udp --dport 514 -j ACCEPT

#Allow outgoing connections to OSSEC server
-A OUTPUT -p udp -m udp --dport 1514 -j ACCEPT

#Log all other "blocked_output_" attempts
-A OUTPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_output_"

#Reply with proper ICMP error message and reject the connection
-A OUTPUT -j REJECT --reject-with icmp-host-prohibited

COMMIT
#
#+END_SRC
** Tasks

*** Save History of Executed Commands
   Commands executed on the servers are logged with the time
   stamp. These logged commands can be referred by the system
   administrator to trouble shoot any issues on the server.

   To save history of commands a shell script is created and placed
   inside =/etc/profile.d= directory. Scripts present inside the
   =/etc/profile.d= directory gets executed at the start of every new
   session.

   Following history parameters are set:

    - HISTTIMEFORMAT :: sets the time format of time stamp
    - HISTSIZE       :: sets the number of lines or commands that are
                        stored in memory in a history list while bash
                        session is ongoing
    - HISTFILESIZE   :: sets the number of lines or commands that are allowed in
                        the history file at start up time of a session, and are
                        stored in the history file at the end of bash session
                        for use in future sessions.

#+BEGIN_SRC shell :tangle roles/lab_role/files/history.sh
#!/bin/bash

HISTTIMEFORMAT="%y %m %d %T"
HISTSIZE=100000
HISTFILESIZE=100000
export HISTTIMEFORMAT HISTSIZE HISTFILESIZE
#+END_SRC

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
#Configure history
- name: Configure history for all users with date/time and 100,000 lines of history
  copy: src=history.sh dest=/etc/profile.d/history.sh mode=755 owner=root group=root
#+END_SRC 

*** Start iptables service
   While setting up the cluster, iptables service is restarted on all
   the servers - to make sure the service is running inside each
   server. If anyone inserts a temporary or adhoc rule using terminal
   commands such as =iptables -A INPUT -p tcp --dport 80 -j ACCEPT=,
   the rules will not be saved in the file. These rules we assume are
   not necessary for the system, so restarting "iptables" will remove
   these inserted rules.

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml

- name: Copy iptables template
  template: src=lab_iptables dest=/etc/iptables.ruleset owner=root group=root

- name: apply iptables rules
  shell: iptables-restore < /etc/iptables.ruleset

#+END_SRC
*** COMMENT Block brute force attempts
   Nodes in the cluster are protected against Brute-force attacks. For
   this *Fail2ban* service is configured on all the nodes. It bans an
   offensive host by adding rule in firewall and also sends an email
   alerts to the system administrator. When the firewall rule for
   offensive host is added, the attacker can not connect to the
   cluster for a limited period of time.

   To configure Fail2ban following actions are performed:
   1) Install fail2ban
   2) Start fail2ban service

#+BEGIN_EXAMPLE
#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
---

#Install fail2ban and enable it on startup
- name: Install fail2ban
  apt: name=fail2ban state=present

- name: Start and enable fail2ban service
  service: name=fail2ban state=started enabled=yes
#+END_SRC
#+END_EXAMPLE


*** Setup /etc/hosts file
   Sendmail tries to lookup hostname and IP mapping through
   =/etc/hosts=. Sendmail assumes the first line in =/etc/hosts= is
   the nodes own FQDN to IP mapping without this sendmail takes about
   30 seconds to timeout for host resolution. To take care of this
   assumption of sendmail =/etc/hosts= file is configured.

   Following variables are set by the ansible playbook scripts as it
   runs on the client node. For each server in the cluster value of
   these variables will be different and set according to the server
   role.

|-------+------------------------------+-------------------------------+--------------------------|
| S.no. | Variable Name                | Description                   | Example                  |
|-------+------------------------------+-------------------------------+--------------------------|
|    1. | ansible_default_ipv4.address | defines the system ip address | 10.1.100.8               |
|-------+------------------------------+-------------------------------+--------------------------|
|    2. | ansible_fqdn                 | define the system fqdn        | ossec.virtual-labs.ac.in |
|-------+------------------------------+-------------------------------+--------------------------|
|    3. | ansible_hostname             | defines the system hostnames  | ossec                    |
|-------+------------------------------+-------------------------------+--------------------------|

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
#Setup /etc/hosts
- name: Configure hostname and fqdn to resolve to local IP on first line of /etc/hosts
#Necessary for containers so that they can send emails without 30 second delay
  lineinfile: dest=/etc/hosts regexp="{{ansible_default_ipv4.address}} {{ansible_fqdn}} {{ansible_hostname}}" insertbefore="BOF" line="{{ansible_default_ipv4.address}} {{ansible_fqdn}} {{ansible_hostname}}"
#+END_SRC

*** Set Name Resolver
   Nameservers are set on all the servers in the cluster. An example
   of configuration file - =/etc/resolv.conf= is shown and described
   below:

#+BEGIN_EXAMPLE
search localdomain.com
nameserver 10.4.12.230
#+END_EXAMPLE

   - search :: This field allows users to type simple names instead of
               complete 'fqdn' to reach local resources. If something
               comes to resolver that has no dots '.' in it, the
               resolver will try adding =localdomain.com= in it.
   - nameserver :: This field specifies the ip address of the dns
                   servers.

   Ansible jinja2 template is copied to the all nodes from the
   configuration server node.

#+BEGIN_SRC conf :tangle roles/lab_role/templates/resolv.conf
{% if private_dns_zone != "none" %}
search {{private_dns_zone}}
{% endif %}
{% for private_dns in private_dns_ips %}
nameserver {{private_dns}}
{% endfor %}
#+END_SRC


*** SSH Hardening
   All the servers in the cluster are made secure by hardening *ssh*
   service. SSH configuration file =/etc/ssh/sshd_config= is
   customized as per the requirement.

**** Permit Root Login without password
   Only system administrators with ssh private key can login as Root.

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: Permit root login without-password(key based)
  lineinfile: dest=/etc/ssh/sshd_config regexp='PermitRootLogin ' line='PermitRootLogin without-password' state=present
#+END_SRC

**** Disable Password based access
   Password based access is disabled.

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: Disable Password authentication
  lineinfile: dest=/etc/ssh/sshd_config regexp='PasswordAuthentication ' line='PasswordAuthentication no'
#+END_SRC


**** Enable Key based authentication
   Only key based access is enabled.

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: Enable Public key authentication
  lineinfile: dest=/etc/ssh/sshd_config regexp='PubkeyAuthentication ' line='PubkeyAuthentication yes'
#+END_SRC


**** Do not permit empty passwords
   Users are not allowed to login with empty passwords.

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: Do not permit empty password, also ensure proper owner, group and permissions
  lineinfile: dest=/etc/ssh/sshd_config regexp='PermitEmptyPasswords ' line='PermitEmptyPasswords no' mode=0600 owner=root group=root
#Call handler to restart sshd
  notify:
      - restart SSH
#+END_SRC


***  Disable Root Login
   Root login is disabled on all the servers in the cluster. Password
   for the root account is set to a value which matches no possible
   encrypted value, therefore nobody can login as root with
   password. Only system administrators with ssh private keys can
   login to root account.

   Root account is locked using =passwd= command command in the
   terminal.  

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: lock root account
  shell: passwd -l root
#+END_SRC


**** Enable root login
   Root login can be enabled by setting the root password using
   following command
#+BEGIN_EXAMPLE
sudo passwd root
#+END_EXAMPLE

**** Unlock root account
   Root login can be unlocked using following command.
#+BEGIN_EXAMPLE
sudo passwd -u root
#+END_EXAMPLE


*** Set the implementation/model release
   Release number is set in all the nodes in the cluster. Release
   number describes the version of the configuration applied on the
   node.

#+BEGIN_SRC yml :tangle roles/lab_role/tasks/main.yml
- name: setting the implementation/model release
  lineinfile: dest=/etc/motd regexp="^Release" line="Release number {{ release_no }}" state=present create=yes
  ignore_errors: yes
#+END_SRC

*** Common Variables
   Variables which are common across all the ansible roles are defined
   in =common_vars= file. The file is included as a dependency for
   this role.

#+BEGIN_SRC yml :tangle roles/lab_role/meta/main.yml
---
dependencies:
  - role: common_vars
#+END_SRC

** Handlers
   When any changes are made in the configuration file of any service, the
   service needs to be restarted. For example, if modifications are made in
   sendmail configuration file to customize sendmail service, then the sendmail
   service needs to be restarted to enforce the modified properties of the
   system.

#+BEGIN_SRC yml :tangle roles/lab_role/handlers/main.yml
---
- name: restart SSH
  service: name=ssh state=restarted
#+END_SRC

** Lab node meta script
   This script unifies and calls the all other tasks listed above.
   This calls the lab_role role, as other roles are not applicable to
   a lab node.

#+BEGIN_SRC yml :tangle lab_role.yaml :eval no
---

- name: This script configures a lab node
  hosts: lab_node
  remote_user: root

  roles: 
    - lab_role
    - rsyslog_client

#+END_SRC

* Test Cases
** Test Case: Port  access
*** Objective
    Check whether SSH and lab control port (TCP 9089) are accessible
    from any lab node to a particular lab and it should not connect.
    ADS will need to have access to SSH, TCP port 9089, configuration
    node to SSH.

*** Requirements
   1) At least two lab nodes
   2) A configruation node
   3) ADS node

*** Procedure
    Use a tool like =netcat= or =telnet= to check whether the ports
    are open,

#+BEGIN_EXAMPLE
telnet <lab_node_ip> <tcp_port_to_test>

telnet 10.100.0.1 22

telnet 10.100.0.1 9089
#+END_EXAMPLE
*** Observation
    The lab node which is being tested should accept connections only
    from Ansible, ADS nodes.
*** Conclusion
   Firewall rules are set properly to allow ssh connection only from
   ansible, nagios and management server.

** Test Case: Root account is locked
*** Objective
   =root= account is locked in a lab node.
*** Experiment
   Execute following command on the server.

#+BEGIN_EXAMPLE
sudo passwd -S root
#+END_EXAMPLE

*** Result
   Output of step-1 signifies the root account is locked.

#+BEGIN_EXAMPLE
root LK 2012-10-07 0 99999 7 -1 (Password locked.)
#+END_EXAMPLE

*** Observation
   Root account is disabled.

*** Conclusion
   Users can not login to the server as 'root' username with password.

** Test Case: Check Command History is getting saved
*** Objective
   To check whether the commands executed on the server are getting
   logged with proper time stamp.
*** Apparatus
   1) A Lab node on which you want to check history

*** Experiment
**** Execute following example sequence of commands on the server
#+BEGIN_EXAMPLE
[root@common-server ~]$ ls
/root
[root@common-server ~]$ pwd
[root@common-server ~]$ echo $PATH
/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin
[root@common-server ~]$ ssh root@router.vlabs.ac.in
ssh: connect to host router.vlabs.ac.in port 22: Connection refused
#+END_EXAMPLE
   Now execute history commands to see whether the commands are
   getting saved with proper time stamp.
#+BEGIN_EXAMPLE
[root@common-server ~]$ history
#+END_EXAMPLE

*** Result
   Output of step-1 of experiment.

#+BEGIN_EXAMPLE
   21  15 04 13 10:27:45ls
   22  15 04 13 10:27:46pwd
   23  15 04 13 10:27:54echo $PATH
   24  15 04 13 10:28:17ssh root@router.vlabs.ac.in
   25  15 04 13 10:28:22history
#+END_EXAMPLE
*** Observation
   History of commands are getting saved with proper time stamp.

*** Conclusion
   History of commands are getting saved with proper time stamp.

** Test Case: Check nameservers are set
*** Objective
   To check nameserver is set on the server for name resolution.

*** Apparatus
   1)  A Lab node on which you want to test DNS

*** Experiment
**** Check content of =/etc/resolv.conf= file.
#+BEGIN_EXAMPLE
cat /etc/resolv.conf
#+END_EXAMPLE

**** Do a dig query for google.com, using nameserver mentioned in =/etc/resolv.conf= file.
#+BEGIN_EXAMPLE
dig google.com @<nameserver-ip>
#+END_EXAMPLE

*** Result
**** Sample output of step-1 of experiment.
#+BEGIN_EXAMPLE
search base1.virtual-labs.ac.in base1.vlabs.ac.in
nameserver 10.100.1.5
#+END_EXAMPLE

**** Sample output of step-2 of experiment.
#+BEGIN_EXAMPLE
; <<>> DiG 9.8.2rc1-RedHat-9.8.2-0.30.rc1.el6_6.2 <<>> google.com @10.100.1.5
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 1314
;; flags: qr rd ra; QUERY: 1, ANSWER: 11, AUTHORITY: 4, ADDITIONAL: 4

;; QUESTION SECTION:
;google.com.			IN	A

;; ANSWER SECTION:
google.com.		300	IN	A	173.194.36.105
google.com.		300	IN	A	173.194.36.100
google.com.		300	IN	A	173.194.36.102
google.com.		300	IN	A	173.194.36.103
google.com.		300	IN	A	173.194.36.99
google.com.		300	IN	A	173.194.36.110
google.com.		300	IN	A	173.194.36.96
google.com.		300	IN	A	173.194.36.101
google.com.		300	IN	A	173.194.36.104
google.com.		300	IN	A	173.194.36.97
google.com.		300	IN	A	173.194.36.98

;; AUTHORITY SECTION:
google.com.		172800	IN	NS	ns2.google.com.
google.com.		172800	IN	NS	ns3.google.com.
google.com.		172800	IN	NS	ns1.google.com.
google.com.		172800	IN	NS	ns4.google.com.

;; ADDITIONAL SECTION:
ns2.google.com.		172800	IN	A	216.239.34.10
ns1.google.com.		172800	IN	A	216.239.32.10
ns3.google.com.		172800	IN	A	216.239.36.10
ns4.google.com.		172800	IN	A	216.239.38.10

;; Query time: 287 msec
;; SERVER: 10.100.1.5#53(10.100.1.5)
;; WHEN: Mon Apr 13 06:08:15 2015
;; MSG SIZE  rcvd: 340
#+END_EXAMPLE

*** Observation
   Server is able to resolve the names using the given nameservers.

*** Conclusion
   Nameservers are properly set on all the servers in the cluster.
