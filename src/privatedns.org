#+TITLE: Private DNS
#+PROPERTY: session *scratch*
#+PROPERTY: results output
#+PROPERTY: exports code
##+SETUPFILE: org-templates/level-0.org

* Introduction
This document describes the requirements, design and implementation of
the *Private Domain Name Server* which is part of the AWS cluster.
This server is used to provide domain name resolution for all other
servers in the cluster. This DNS is used for internal name resolution.
Also it is used for the internal machines to resolve the external
domain names(gnu.org). Using Ansible, a machine is configured using
multiple roles. A role is a specific set of configurations.

* Requirements
The functional and security requirements of the Private DNS are
mentioned in the following sections. These are specific the Private
DNS. The requirements which are common to all the servers are mentioned
in the [[common%20role][common role]].
** Functional
   - Resolve our authoritative domain names for all internal clients
   - Zone entries should be configurable (from a particular file on
     ansible server)
   - Resolve all domain names for internal clients (Peer DNS).
** Security
   - Allow port 53 (UDP) *only* from any machine in the cluster.

* Design
** Overall network diagram of Private DNS
#+CAPTION:  Private DNS Network Diagram
#+LABEL:  fig-private-dns-diagram
#+NAME: fig-private-dns-diagram
The following network diagram represents the interaction of the
Private DNS with the other machines in the cluster. This diagram
primarily focuses on the functionality of the Named server. It shows
the various machines in the network to which it provides its
service.\\

The other machines in the cluster use the Private DNS for resolving
the hostnames of machines in the cluster. The Private DNS requires
the Router to be able to contact the root DNS servers for providing
the internal machines to update or install certain packages.

[[./diagrams/private-dns-network-diagram.png]]

** System files 
The following table gives the information about the services and their
configuration files where modifications are required to setup the
Named Server.
|------+----------+-------------------------------+--------------------------------|
| S.no | Service  | File                          | File Type                      |
|------+----------+-------------------------------+--------------------------------|
|    1 | named    | /etc/name.conf                | named main Configuration       |
|------+----------+-------------------------------+--------------------------------|
|    2 | named    | /var/named/<domain_name>.zone | Zone files for the authorized  |
|      |          |                               | name resolution of that domain |
|------+----------+-------------------------------+--------------------------------|
|    3 | iptables | /etc/sysconfig/iptables       | firewall rules                 |
|------+----------+-------------------------------+--------------------------------|
|    4 | named    | /etc/sysconfig/named          | Disable IPv6 support           |
|------+----------+-------------------------------+--------------------------------|

* Implementation
** Structure of the scripts
   - The implementation of this system is in terms of a collection of
     Ansible scripts that configure the machine. These scripts are
     organized as follows:

#+BEGIN_EXAMPLE
|-code
|   |-- privatedns.yml
|   |-- roles
|   |   |-- named_server
|   |   |   |-- handlers
|   |   |   |   `--main.yaml
|   |   |   |-- tasks
|   |   |   |   `--main.yaml
|   |   |   |-- templates
|   |   |   |   `--main.yaml
|   |   |   |-- vars
|   |   |   |   `--main.yaml
|   |   |   |-- meta
|   |   |       `--main.yaml
#+END_EXAMPLE

** Installing the bind service
   The BIND service has to be setup for configuring the machine as a
   DNS. This is done by the following code:

#+BEGIN_SRC YAML :tangle roles/named_server/tasks/main.yaml
---
- name: Install bind and bind-utils package
  yum: name="{{item}}" state=present
  with_items:
    - bind
    - bind-utils
#+END_SRC

** Configuring the Bind service
   The named server has to be configured. This is done in the file
   named =/etc/named.conf=. We specify the domain for which this
   server should be the authoritative name server. These are termed as
   zone in the configuration file. Each zone will have a corresponding
   zone file which enlists the sub-domains present in under that
   domain.

#+BEGIN_SRC YAML :tangle roles/named_server/tasks/main.yaml
- name: Create custom named.conf with desired zone
  template: src=named.conf dest=/etc/named.conf owner=root group=named mode=640
  notify:
    - restart bind
#+END_SRC

The named.conf file looks like this:

#+BEGIN_SRC YAML :tangle roles/named_server/templates/named.conf
//
// named.conf
//
// Provided by Red Hat bind package to configure the ISC BIND named(8) DNS
// server as a caching only nameserver (as a localhost DNS resolver only).
//
// See /usr/share/doc/bind*/sample/ for example named configuration files.
//

options {
        listen-on port 53 { 127.0.0.1; any; };
        listen-on-v6 port 53 { ::1; };
        directory       "/var/named";
        dump-file       "/var/named/data/cache_dump.db";
        statistics-file "/var/named/data/named_stats.txt";
        memstatistics-file "/var/named/data/named_mem_stats.txt";
        allow-query     { localhost; {{allow_query_from}} };
        recursion {{recursion}};

        dnssec-enable no;
        dnssec-validation no;
        dnssec-lookaside auto;

        /* Path to ISC DLV key */
        bindkeys-file "/etc/named.iscdlv.key";

        managed-keys-directory "/var/named/dynamic";
};

logging {
        channel default_debug {
                file "data/named.run";
                severity dynamic;
        };
};
% for item in zone_names  %}

zone "{{item}}" IN {
   type master;
   file "{{item}}forward";
};

{% endfor %}


zone "." IN {
        type hint;
        file "named.ca";
};

include "/etc/named.rfc1912.zones";
include "/etc/named.root.key";
#+END_SRC

** Creating the zone files
   Each zone (domain) is associated with a zone file which contains a
   list of all the sub-domains under that domain and also their
   corresponding IP address to which the request for that FQDN should
   be sent to.
#+BEGIN_SRC YAML :tangle roles/named_server/tasks/main.yaml
- name: Copy zone forward files for all zones to /var/named
  template: src="zone.forward" dest="/var/named/{{item}}forward" owner=root group=named mode=640
  with_items: zone_names
  notify:
    - restart bind
#+END_SRC

The zone file template looks like the following:

#+BEGIN_SRC YAML :tangle roles/named_server/templates/zone.forward
$TTL 3600
@ SOA ns.{{item}} root.{{item}} (1 15m 5m 30d 1h)
                IN      NS      {{name_server}}
                IN      A       {{zone_address}}

{% for server1 in servers %}

{{server1.hostname}}    IN      A       {{server1.ip}}

{% endfor %}
#+END_SRC

** Some more configuration
   We disable the IPv6 support. 
#+BEGIN_SRC  YAML :tangle roles/named_server/tasks/main.yaml
- name: Disable IPv6 support
  lineinfile: dest=/etc/sysconfig/named line='OPTIONS="-4"' regexp="^OPTIONS"
  notify:
    - restart bind
#+END_SRC

** Bringing up the Bind service
   After configuring the named server we now need to start the service.
#+BEGIN_SRC YAML :tangle roles/named_server/tasks/main.yaml
- name: Start and enable bind service
  service: name=named state=started enabled=yes
#+END_SRC

** Building the  firewall rules
   The firewall rules have to be configured. The rules required are as
   listed below:
#+BEGIN_SRC YAML :tangle roles/named_server/templates/named_iptables
*filter
:INPUT ACCEPT [-1:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
#Accept loopback connections
-A INPUT -i lo -d 127.0.0.0/8 -j ACCEPT
#Rate limit new connections to 20 new connections per 30 seconds
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --set
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --rcheck --seconds 30 --hitcount 20 -m limit --limit 2/min -j LOG --log-prefix "new_limit_"
-A INPUT ! -p udp -m state --state NEW -m recent --name ssh_limit --rcheck --seconds 30 --hitcount 20 -j DROP
#Accept ICMP ping requests at limited rate
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 60/minute --limit-burst 120 -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/minute --limit-burst 2 -j LOG
-A INPUT -p icmp --icmp-type echo-request -j DROP
#Allow ongoing connections
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
#Allow incoming SSH connections from management IPs.  Hopefully fail2ban will take care of bruteforce attacks from management IPs
{% for item in management_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming SSH connections from ansible server IPs.  Hopefully fail2ban will take care of bruteforce attacks from ansible server IPs
{% for item in ansible_server_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming SSH connections from nagios server IPs.  Hopefully fail2ban will take care of bruteforce attacks from ansible server IPs
{% for item in nagios_server_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#Allow access to DNS from everywhere.  The allow_query option in DNS will take care of limiting clients. 
-A INPUT -m state --state NEW -p udp -m udp --dport 53 -j ACCEPT
#Allow incoming NRPE queries for nagios from nagios servers
-A INPUT -m state --state NEW -p tcp -m tcp --dport 5666 -j ACCEPT
#Allow SNMP queries from cacti servers
#-A INPUT -p udp -m udp --dport 161 -j ACCEPT
#-A INPUT -p udp -m udp --dport 162 -j ACCEPT
#Log all other "blocked_input_" attempts with rate limiting
-A INPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_input_"
#Reply with proper ICMP error message and reject the connection
-A INPUT -j REJECT --reject-with icmp-host-prohibited
#Disable packet forwarding through firewall
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
#
#
##Output rules
#Allow outgoing connections to localhost
-A OUTPUT -s 127.0.0.0/8 -o lo -j ACCEPT
#Allow outgoing replies to ansible from SSH server
{% for item in ansible_server_ips  %}
-A OUTPUT -d {{item}} -p tcp -m tcp --sport 22 -j ACCEPT
{% endfor %}
#Allow ongoing connections
-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
#Allow DNS queries
-A OUTPUT -p udp -m udp --dport 53 -j ACCEPT
#Allow server to send emails.  Required for sending logwatch emails
-A OUTPUT -p tcp -m tcp --dport 25 -j ACCEPT
#Allow server to contact web-servers.  Required for yum update and installation
#For restrictive configurations this can be disabled after install
-A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 443 -j ACCEPT
#Allow outgoing connections to rsyslog server
-A OUTPUT -p udp -m udp --dport 514 -j ACCEPT
#Allow outgoing connections to OSSEC server
-A OUTPUT -p udp -m udp --dport 1514 -j ACCEPT
#Allow outgoing ping requests
-A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT
#Log all other "blocked_output_" attempts
-A OUTPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_output_"
#Reply with proper ICMP error message and reject the connection
-A OUTPUT -j REJECT --reject-with icmp-host-prohibited
COMMIT
#
#+END_SRC

** Apply the firewall rules
   The firewall rules which were mentioned in the previous section
   need to be applied. This is done from the following script.
#+BEGIN_SRC YAML :tangle roles/named_server/tasks/main.yaml
- name: Configure strong firewall on bind/named server
  template: src=named_iptables dest=/etc/sysconfig/iptables
  notify:
    - restart iptables
#+END_SRC

** Handlers
   The services should be restarted if there are any changes made to
   the configuration file. this is taken care of by the following
   code.
#+BEGIN_SRC YAML :tangle roles/named_server/handlers/main.yaml
---
- name: restart bind
  service: name=named state=restarted

- name: restart iptables
  service: name=iptables state=restarted
#+END_SRC
** Creating the Private DNS
   The Private DNS can be setup from the role described above. All the
   above mentioned steps need to be implemented. This is done by the
   main configuration file, which calls all the steps above in the
   required sequence.
#+BEGIN_SRC YAML :tangle privatedns.yaml 
---
- name: This file configures private dns server
  hosts: private_dns
  remote_user: root

  vars:
    zone_file_prefix: private.
    zone_names:
      - virtual-labs.ac.in.
      - vlabs.ac.in.
    zone_address: 10.100.1.7
    allow_query_from: "10.0.0.0/8; 172.16.0.0/12; 192.168.0.0/16;"
    name_server: private-dns
    recursion: yes
    servers:
      - { hostname: router, ip: 10.100.1.1 }
      - { hostname: ansible, ip: 10.100.1.2 }
      - { hostname: ossec-server, ip: 10.100.1.3 }
      - { hostname: rsyslog-server, ip: 10.100.1.4 }
      - { hostname: private-dns, ip: 10.100.1.5 }
      - { hostname: public-dns, ip: 10.100.1.6 }
      - { hostname: reverseproxy, ip: 10.100.1.7 }
      - { hostname: nagios, ip: 10.100.1.8 }
      - { hostname: lab1, ip: 10.100.1.50 }
      - { hostname: lab2, ip: 10.100.1.51 }
#      - { hostname: git-server, ip: 10.4.12.185 }

  roles:
    - common
    - rsyslog_client
    - ossec_client
    - nagios_client
    - named_server
#+END_SRC

** COMMENT Dependencies
#+BEGIN_SRC 
---
dependencies:
  - role: common_vars
#+END_SRC


* COMMENT Provisioning
  The Private DNS server is setup by the Configuration management
  server. The machine configurations are as described below :

** Creation
   The bare machine to setup a Private DNS is created using the AWS
   console by providing the private IP address.

** Machine Configuration
   + OS :: Centos 6.6
   + Architechture :: x86_64
   + Memory :: 1024MB
   + Disk space :: 25GB
   + Interface :: eth0
** Access 
   This machine can be accessed only by the configuration management server.


* Test Cases
** Test case ID: TC01
*** Objective
    The objective is to test the working of the name server to resolve
    the hostnames of other machines which have been configured in the
    Private DNS zone file.
*** Apparatus
    - The Private DNS container/machine
    - Another machine in the same network
*** Theory
    The named server contains a list of hostnames with their
    corresponding IP addresses. Once the service is running it is
    capable of resolving these hostnames to their respective IP
    addresses. There are command-line tools available which help in
    querying the DNS server. For our test case we use =nslookup= and
    =dig=. Both of them are command-line tools which query the
    DNS. Since this test is being done by the systems engineer, he
    would know the configured IP addresses of the hostnames. This
    helps in knowing if the result of the query is right or wrong.
*** Procedure
    - First we take a another machine in the same network as that of
      the name-server.
    - Now we need to install the command-line tools we need to do the
      following: for a ubuntu machine
      #+BEGIN_EXAMPLE
      sudo apt-get install bind-utils
      #+END_EXAMPLE
      or (for a centos machine)
      #+BEGIN_EXAMPLE
      sudo yum install bind-utils
      #+END_EXAMPLE
    - Now we need to set the name server of this machine to be the
      Private DNS machine that we just configured. For this we need to
      edit the file =/etc/resolv.conf=. The content of the file should
      be as below:
      #+BEGIN_EXAMPLE
      nameserver <IP of the Private DNS>
      #+END_EXAMPLE
    - Now on this machine we need to run the command-line tool to
      query the DNS server. These tools might not be installed on all
      machines by default, so we need to install them.
    - Now we run the tools as follows:
      #+BEGIN_EXAMPLE
      dig <FQDN>
      #+END_EXAMPLE
    - We can also use the nslookup tool.
      #+BEGIN_EXAMPLE
      nslookup <FQDN>
      #+END_EXAMPLE
    - By running these commands we can determine if the DNS is
      resolving the names properly or not.

*** Experiments
    We need to perform testing by using the command line tools. In the
    terminal of the other machine do the following:
    #+BEGIN_EXAMPLE
    nslookup ossec-server.base1.virtual-labs.ac.in
    #+END_EXAMPLE
    and 
    #+BEGIN_EXAMPLE
    dig ossec-server.base1.virtual-labs.ac.in
    #+END_EXAMPLE
*** Result
    - The result obtained from the first command is as below : 
    #+BEGIN_EXAMPLE
    Server:		10.100.1.5
    Address:	10.100.1.5#53

    Name:	ossec-server.base1.virtual-labs.ac.in
    Address: 10.100.1.3
    #+END_EXAMPLE
    - The result obtained from the second command is as below:
    #+BEGIN_EXAMPLE
    ; <<>> DiG 9.8.2rc1-RedHat-9.8.2-0.30.rc1.el6_6.2 <<>> ossec-server.base1.virtual-labs.ac.in
    ;; global options: +cmd
    ;; Got answer:
    ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 9080
    ;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 1

    ;; QUESTION SECTION:
    ;ossec-server.base1.virtual-labs.ac.in. IN A

    ;; ANSWER SECTION:
    ossec-server.base1.virtual-labs.ac.in. 3600 IN A 10.100.1.3

    ;; AUTHORITY SECTION:
    base1.virtual-labs.ac.in. 3600	IN	NS	private-dns.base1.virtual-labs.ac.in.

    ;; ADDITIONAL SECTION:
    private-dns.base1.virtual-labs.ac.in. 3600 IN A	10.100.1.5

    ;; Query time: 0 msec
    ;; SERVER: 10.100.1.5#53(10.100.1.5)
    ;; WHEN: Mon Apr  6 05:57:26 2015
    ;; MSG SIZE  rcvd: 113
    #+END_EXAMPLE

*** Observation
    From the results obtained above it can be observed that both the
    queries give the output of the query made to the DNS server. The
    output of dig queries are generally more descriptive and detailed
    than nslookup. The crux of both of these command line tools is to
    determine if the query for a particular FQDN gave the
    corresponding IP of that machine to which the domain name belongs,
    which both do.  The given FQDN was
    =ossec-server.base1.virtual-labs.ac.in=. The obtained result
    showed that this FQDN belonged to a machine with IP =10.100.1.3=.
    This shows that the Private DNS was able to resolve the hostname
    of the server to its corresponding IP address. The same IP was
    configured against this hostname in the Private DNS.

*** Conclusion
    The Private DNS is resolving the hostnames correctly.


** Test case ID: TC02
*** Objective
    The objective is to test if the Private DNS works as a Peer DNS.
*** Apparatus
    - The Private DNS container/machine
    - Another machine in the same network.
*** Theory
    The Private DNS should be able to resolve external domain names
    for the machine to be able to contact external sources. This is
    mainly required when we are updating the machine or trying to
    install any package. The mere presence of internet access is not
    sufficient. The machine requires the facility to be able to
    resolve hostnames as well.
*** Procedure
    - First we need to check the =/etc/resolv.conf= file in a machine
      which is a part of the same network as that of the Private DNS. 
    - The nameserver should be set as the IP of the Private DNS.
    - Now, in the machine we should be able to resolve the IP
      addresses of gnu.org or google.com using dig and nslookup.
      #+BEGIN_EXAMPLE
      nslookup gnu.org <Private DNS IP>
      #+END_EXAMPLE
      and
      #+BEGIN_EXAMPLE
      dig gnu.org @<Private DNS IP>
      #+END_EXAMPLE
*** Experiments
    - To test if we can resolve gnu.org using nslookup
    #+BEGIN_EXAMPLE
    nslookup gnu.org 10.100.1.5
    #+END_EXAMPLE
    - To test if we can resolve gnu.org using dig
    #+BEGIN_EXAMPLE
    dig gnu.org @10.100.1.5
    #+END_EXAMPLE
*** Result
    - The result for the first case with nslookup is as below:
    #+BEGIN_EXAMPLE
    Server:		10.100.1.5
    Address:	10.100.1.5#53

    Non-authoritative answer:
    Name:	gnu.org
    Address: 208.118.235.148
    #+END_EXAMPLE
    - The result of the first case with dig is as below:
    #+BEGIN_EXAMPLE
    ; <<>> DiG 9.8.2rc1-RedHat-9.8.2-0.30.rc1.el6_6.2 <<>> gnu.org @10.100.1.5
    ;; global options: +cmd
    ;; Got answer:
    ;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 2113
    ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 4, ADDITIONAL: 7

    ;; OPT PSEUDOSECTION:
    ; EDNS: version: 0, flags:; udp: 4096
    ;; QUESTION SECTION:
    ;gnu.org.			IN	A

    ;; ANSWER SECTION:
    gnu.org.		158	IN	A	208.118.235.148

    ;; AUTHORITY SECTION:
    gnu.org.		158	IN	NS	ns4.gnu.org.
    gnu.org.		158	IN	NS	ns2.gnu.org.
    gnu.org.		158	IN	NS	ns1.gnu.org.
    gnu.org.		158	IN	NS	ns3.gnu.org.

    ;; ADDITIONAL SECTION:
    ns3.gnu.org.		86258	IN	A	46.43.37.70
    ns3.gnu.org.		86258	IN	AAAA	2001:41c8:20:2d3::a
    ns4.gnu.org.		158	IN	A	208.70.31.125
    ns2.gnu.org.		86258	IN	A	87.98.253.102
    ns1.gnu.org.		86258	IN	A	208.118.235.164
    ns1.gnu.org.		86258	IN	AAAA	2001:4830:134:3::f

    ;; Query time: 0 msec
    ;; SERVER: 10.4.12.160#53(10.4.12.160)
    ;; WHEN: Tue Apr 07 10:55:36 IST 2015
    ;; MSG SIZE  rcvd: 244
   #+END_EXAMPLE
*** Observation
    The results show that the Private DNS is being used to query the
    IP address of =gnu.org=. Nslookup shows us the IP of gnu.org. It
    also specifies that this reply is non authoritative. This is
    because our Private DNS server is not the authoritative server for
    gnu.org. The result from the dig command also shows the same
    inference. the dig command output shows that all the IPs of the
    authoritative servers of gnu.org.

*** Conclusion
    The Private DNS is able to resolve the public domain names as
    well.
