#+TITLE:  Configuration Server
#+PROPERTY: session *scratch*
#+PROPERTY: results output
#+PROPERTY: exports code
#+SETUPFILE: org-templates/level-0.org
#+options: ^:nil
 
* Introduction
  In this documentation, we call config-server as ansible server, configuration
  server and also node.
  
  This document describes the requirements, design and implementation of the
  configuration server.
  
  This configuration server plays a vital role in the cluster to complete the
  infrastructure. Since configuration server configures all other nodes in the
  cluster and configures itself as well, through multiple roles and tasks. A
  role is a specific set of configurations.

  It contains all the ansible-scripts to bring up the other nodes. The purpose
  of this server is to avoid manual configuration of nodes by team members. The
  mechanism ansible provides to configure other nodes is via ssh.
 
  The configuration server will be able to ssh to other servers and lab
  instances/containers using *key based authentication only* since public key of
  configuration server will be placed in all other servers/nodes,
  instances/containers and itself also. Password based authentication is not
  allowed to this node

  The services to register and de-register labs provided by the configuration
  server are also captured in the document.

** COMMENT Only from management ip machines, we will be able ssh to root account
of configuration server. Password based authentication is not allowed
to root user, only key based authentication is allowed from specific
ip machines.  

- Note  ::  In future we can have non-root(normal) user to
            ssh to configuration server only from management ip
            machines.

* Requirements
 The requirements of the config-server which differ from the generic
 requirements(specified in common-role) are mentioned here.

** Functional Requirements
   1. Configuration server will configure all the nodes in the cluster
      including itself and ensures that the configuration is
      consistent.
   2. Configuration server has only one `root' user.
   3. Only authorized VLEAD members can login as 'root' user from IIIT
      IP range or management ip machines using key based
      authentication only.
   4. Provide service to register and de-register labs. 

** Security Requirements
   The Configuration server accepts incoming connections on port 22
   *only* from IIIT IP range or management ip machines.
* Design
** Configuration
  The following network diagram represents how the configuration
  server is connecting to other nodes such as reverse proxy, DNS,
  router etc.

  #+CAPTION:  Configuration Server Design Diagram
  #+LABEL:  fig-config-diagram
  [[./diagrams/config-server-network-diagram.png]]
   
  Configuration server is one of the many other nodes in the cluster.
  Only IIIT IP range and management ip machines are allowed to ssh to
  root account of the configuration server.

  The design of the firewall rules ensures that this server is
  accessible only via port 22.  

  SSH access to the node is allowed only via *key-based
  authentication*. Password based authentication is not allowed to the
  root user. SSH configuration, fail2ban and locking root user
  password are taken care by common role. For more tasks which are
  done by common role to the node are described in [[./common.org][common role]].
  
  The Configuration server can be reached via ICMP (ping) requests.
  Public key of the configuration server will be placed in every
  instance/container. So the configuration server will be able to
  configure all other nodes, instances/containers and as well as
  itself by running the ansible scripts. These ansible scripts are
  described and implemented at the [[Implementation][implementation]] section.

** Services
  #+CAPTION:  Configuration Server Services Design Diagram
  #+LABEL:  fig-config-services-diagram
  [[./diagrams/hooks2.png]]

*** Description
- Hosting of a Lab ::
Hosting a lab means instantiating a new node in the cluster, then deploying a
lab on it. Once the lab is being deployed the entries for DNS, reverseproxy,
nagios and awstats are made. Once the entries are done the lab becomes
accessible from the internet.

- Registration ::
A lab is said to be registered by the service when the necessary configuration
changes are done and lab is accessible from external world.

- De registration ::
A lab is said to be de-registered by the service when the various entries are
removed from the servers and lab is no longer accessible.

- Work Flow of the Service ::
ADS invokes the services provided by the configuration server over SSH to
register or de register a lab. Service program first writes the input arguments
passed by the ADS into a data file (.txt). Then the data is appended in the yaml
file. Ansible playbook is then run to reconfigure the whole cluster again.

**** DONE What is Hosting and deployment of labs
**** DONE Explain how service is invoked, makes the necessary configuration changes in the cluster.
**** DONE Register: Lab is available from the external world, similarly deregister.
**** DONE Describe the arguments taken by the program as input.
**** DONE Run Ansible playbook to reconfigure the whole cluster again.
**** TODO Link to ads server how it is configured to call service.
**** TODO Failure condition

** System Configuration files Summary

The following table gives the information about services and their configuration
files. Other configuration files are updated in common role.
|-----------+-----------------------------------+---------------------------|
| *Service* | *Configuration file*              | *Description*             |
|-----------+-----------------------------------+---------------------------|
| firewall  | =/etc/sysconfig/iptables/=        | configuration server Role |
|-----------+-----------------------------------+---------------------------|
| IP        | =/etc/sysconfig/network-scripts/= | amazon console            |
|-----------+-----------------------------------+---------------------------|

#+TBLFM: $2=/etc/sysconfig/network-scripts

* Implementation
** Configuration
  The implementation of the configuration server is done with the
  following steps.
  - Note :: In this implementation, variables are used in various
            places using "{}". Values of these variables are defined
            in [[common_vars.org][common_vars role]].

*** Structure of the scripts
   The implementation of this system is in terms of a collection of
   ansible scripts that configures the machine. The scripts are organized as
   follows:

#+BEGIN_EXAMPLE
|-- config_server.yml
|-- roles
|   |-- config_server
|   |   |-- handlers
|   |   |   `-- main.yml
|   |   |-- tasks
|   |   |   |-- main.yml
|   |   `-- templates
|   |       `-- iptables

#+END_EXAMPLE

   Here =config_server.yml= file configures the configuration server
   with the config_server and all other roles. The other roles are:
    - [[./common.org][common]]
    - rsyslog_client
    - ossec_client
    - nagios_client
    - config_server

   =roles/config_server/handlers/main.yml= file defines various
   handlers which are only executed in case a task notifies
   them. Handlers are described in details at [[Handlers][handlers]].  The handlers
   are called only when tasks are called as part of the config_server
   role. Various templates and files are being used during task
   execution for creating necessary configuration files.

   =roles/config_server/tasks/main.yml= file consist of various tasks
   which are needed for setting up config_server. These tasks are
   implemented and described [[Tasks][here]].
   
   =roles/config_server/templates/iptables= template file consist of
   various firewall rules in order to configure this node securely by
   running the [[Apply firewall rules to Configuration server][task]]. This template uses various variables and these
   variable values are defined in common_vars role. This template is
   created at [[Firewall rules]] section and you can see the description
   each firewall.

*** Tasks
**** Firewall rules
    Rules which are specific to configuration server are described [[Firewall rules specific to config_server][below]].
    Description of each firewall rule of this configuration server and
    which are common across all the systems are described in [[.common.org][common role]].

#+BEGIN_SRC yaml :tangle roles/config_server/templates/iptables
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [0:0]
#Allow internal process to process communication over loopback interface
# Accept loopback connections
-A INPUT -i lo -d 127.0.0.0/8 -j ACCEPT
#Rate limit new connections to 20 new connections per 30 seconds
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --set
-A INPUT ! -p udp -m state --state NEW -m recent --name new_limit --rcheck --seconds 30 --hitcount 20 -m limit --limit 2/min -j LOG --log-prefix "new_limit_"
-A INPUT ! -p udp -m state --state NEW -m recent --name ssh_limit --rcheck --seconds 30 --hitcount 20 -j DROP
#Accept ICMP ping requests at limited rate
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 60/minute --limit-burst 120 -j ACCEPT
-A INPUT -p icmp --icmp-type echo-request -m limit --limit 1/minute --limit-burst 2 -j LOG
-A INPUT -p icmp --icmp-type echo-request -j DROP

#Allow ongoing connections
-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
{% for ip in nagios_server_ips %}
-A INPUT -p tcp -m tcp -s {{ip}} --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming SSH connections from management IPs.  Hopefully fail2ban will take care of bruteforce attacks from management IPs
{% for item in management_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming SSH connections from ansible_server IPs.  Hopefully fail2ban will take care of bruteforce attacks from management IPs
{% for item in ansible_server_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming SSH connections from rsnapshot_server IPs.  Hopefully fail2ban will take care of bruteforce attacks from management IPs
{% for item in rsnapshot_server_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#Allow incoming NRPE queries for nagios from nagios servers
-A INPUT -m state --state NEW -p tcp -m tcp --dport 5666 -j ACCEPT
#Log all other "blocked_input_" attempts with rate limiting
-A INPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_input_"

#Reply with proper ICMP error message and reject the connection
-A INPUT -j REJECT --reject-with icmp-host-prohibited
#Do not allow any packet to be forwarded
-A FORWARD -j REJECT --reject-with icmp-host-prohibited

##Output rules
#Allow outgoing connections to localhost
-A OUTPUT -s 127.0.0.0/8 -o lo -j ACCEPT

#Allow ongoing connections
-A OUTPUT -m state --state RELATED,ESTABLISHED -j ACCEPT

#Allow DNS queries
-A OUTPUT -p udp -m udp --dport 53 -j ACCEPT

#Allow server to send emails.  Required for sending logwatch emails
-A OUTPUT -p tcp -m tcp --dport 25 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 22 -j ACCEPT

# 80 and 443 OUTPUT is needed for yum update and to install packages
-A OUTPUT -p tcp -m tcp --dport 80 -j ACCEPT
-A OUTPUT -p tcp -m tcp --dport 443 -j ACCEPT

#Allow outgoing ping requests
-A OUTPUT -p icmp --icmp-type echo-request -j ACCEPT

#Allow outgoing connections to rsyslog server
-A OUTPUT -p udp -m udp --dport 514 -j ACCEPT

#Allow outgoing connections to OSSEC server
-A OUTPUT -p udp -m udp --dport 1514 -j ACCEPT
#Log all other "blocked_output_" attempts
-A OUTPUT -m state --state NEW -m limit --limit 2/min -j LOG --log-prefix "blocked_output_"

#Reply with proper ICMP error message and reject the connection
-A OUTPUT -j REJECT --reject-with icmp-host-prohibited
COMMIT
#+END_SRC
**** Firewall rules specific to config_server

***** SSH access from management ips
     The following firewall rule accepts incoming connections on tcp
     port 22 only from management ips

#+BEGIN_SRC example
{% for item in management_ips  %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#+END_SRC

***** SSH access from ansible server ips
     The following firewall rule accepts incoming connections on tcp
     port 22 only from ansible server ips

#+BEGIN_SRC example
{% for item in ansible_server_ips %}
-A INPUT -m state --state NEW -s {{item}} -p tcp -m tcp --dport 22 -j ACCEPT
{% endfor %}
#+END_SRC

**** Installing ansible 
    Install latest ansible package to setup the configuration server
    itself and to run the ansible scripts to configure the other nodes
    in the cluster.

#+BEGIN_SRC yaml :tangle roles/config_server/tasks/main.yml
---
- name: installing ansible
  yum: name=ansible state=present
#+END_SRC
**** Apply firewall rules to Configuration server
    Firewall rules are applied by following steps:
    1) Copy the =iptables= template to the configuration server.
    2) Restart iptables service if the configuration file is modified
       and apply the configuration.

#+BEGIN_SRC yaml :tangle roles/config_server/tasks/main.yml
- name: Copy iptables configuration file for configuration server
  template: src=iptables dest=/etc/sysconfig/iptables mode=600 owner=root group=root
  notify: restart iptables
#+END_SRC

**** Handlers
   Restart the iptables service if configuration file of iptables is
   modified. These handlers are called only when tasks notifies to
   start service.

#+BEGIN_SRC yaml :tangle roles/config_server/handlers/main.yaml 
---
- name: restart iptables
  service: name=iptables state=restarted
#+END_SRC

**** Main configuration file
   The configuration server is managed with all other roles. The
   implementation is done in terms of defining suitable scripts for
   each role.  The top level script is =build/code/config_server.yml=

#+BEGIN_SRC yaml :tangle config_server.yaml
---
- name: This file configures ansible server
  hosts: ansible_server
  remote_user: root

  vars:
    i_ans: yes
    host_name: ansible

  roles:
    - common
    - rsyslog_client
    - ossec_client
    - nagios_client
    - config_server
#+END_SRC

** Services
ADS invokes multiple services exposed by the configuration server as follows:
#+BEGIN_EXAMPLE
python config-services <service name> arguments
#+END_EXAMPLE

- Program Design ::
The program takes the following three arguments as input:
1. A keyword - (register or de register)
2. IP Address - ipaddress of the lab
3. FQDN - Frequently Qualified Domain Name of the lab

*** Format of the data file
The arguments passed to the service are saved in the following format in a data
file.

#+BEGIN_EXAMPLE
router 10.100.1.1
bandwidthd 10.100.1.1
ansible 10.100.1.2
ossec-server 10.100.1.3
rsyslog-server 10.100.1.4
private-dns 10.100.1.5
public-dns 10.100.1.6
#+END_EXAMPLE

*** Format of the "yaml" file
Program then converts the data into a proper "yaml" format.

#+BEGIN_EXAMPLE
- { hostname: router, ip: 10.100.1.1 }
- { hostname: bandwidthd, ip: 10.100.1.1 }
- { hostname: ansible, ip: 10.100.1.2 }
- { hostname: ossec-server, ip: 10.100.1.3 }
- { hostname: rsyslog-server, ip: 10.100.1.4 }
- { hostname: private-dns, ip: 10.100.1.5 }
- { hostname: public-dns, ip: 10.100.1.6 }
#+END_EXAMPLE

*** Service Program
#+BEGIN_SRC python :tangle service.py :eval no
import sys 

from format import *

def register(hostname, ip):

    labFile = open("lab.txt", "a")
    
    labFile.write("%s %s\n" %(hostname, ip))

    labFile.close()

    reverseproxy("lab.txt", "main.yml")

    dns("lab.txt", "main.yml")

    return

#def deregister():

def main(argv):
#    print argv
    print argv[0], argv[1], argv[2]
    if (str(argv[0]) == "register"):
        register(argv[1], argv[2])

    return

if __name__ == "__main__":
    main(sys.argv[1:])
#+END_SRC

*** Author Name
#+BEGIN_SRC python :tangle format.py :eval no
#Author: Yogesh Agrawal
#Date: 2015, June 26. Friday
#Email: yogesh@vlabs.ac.in
#+END_SRC

*** Registering DNS Entries
DNS entries of the labs are to be made in order for the labs to be accessible by
its FQDN. FQDN and ipaddresses are read from the data file and appended to DNS
"yaml" file.
**** Function definition
#+BEGIN_SRC python :tangle format.py :eval no
def dns(inputFile, outputFile):
#+END_SRC

**** Open Input File and Output File
Open input file - "lab.txt" to read the content. Also open output file -
"private_dns.yaml" to write data.

#+BEGIN_SRC python :tangle format.py :eval no
    labFile = open(inputFile, "r")
    ymlFile = open(outputFile, "r")
#+END_SRC

**** Read yml file
Read yml file line by line and save data in a variable.
#+BEGIN_SRC python :tangle format.py :eval no		
    ymlData = ymlFile.readlines()
#+END_SRC

**** Find start and end index of markers
Find the start and the end index of the markers in the yml file.
#+BEGIN_SRC python :tangle format.py :eval no	
    dnsStartIndex = ymlData.index("#DNS_START\n")
    dnsEndIndex = ymlData.index("#DNS_END\n")
#+END_SRC

**** Save existing entries in a variable
Data is in between the markers, so entries are fetched from file and saved in a
variable.
#+BEGIN_SRC python :tangle format.py :eval no
    dnsExistingEntries = []

    for index in range(dnsStartIndex + 2, dnsEndIndex):
        dnsExistingEntries.append(ymlData[index])
#+END_SRC

**** Save new entries in the variable
New entries are appended in the same variable with proper format.
#+BEGIN_SRC python :tangle format.py :eval no
    dnsNewEntries = []

    for line in labFile.readlines():
        splitLine = line.split()
	hostnameAndIP = " - { hostname: %s, ip: %s }\n" %(splitLine[0], splitLine[1])
	dnsNewEntries.append(hostnameAndIP)
#+END_SRC

**** Combine existing and new entries in a variable
#+BEGIN_SRC python :tangle format.py :eval no
    dnsTotalEntries = dnsExistingEntries + dnsNewEntries
#+END_SRC

**** Remove duplicate entries
Remove duplicates by converting list into set first and then again into list.
#+BEGIN_SRC python :tangle format.py :eval no
    dnsTotalEntries = list(set(dnsTotalEntries))
#+END_SRC

**** Complete file content
#+BEGIN_SRC python :tangle format.py :eval no
    delimeter = list("#DNS_END\n")
    newYmlData = ymlData[0:dnsStartIndex + 2] + dnsTotalEntries + delimeter
#+END_SRC

**** Close file pointers
#+BEGIN_SRC python :tangle format.py :eval no
    labFile.close()
    ymlFile.close()
#+END_SRC

**** Write complete data to a file
Data is written to a file line by line.
#+BEGIN_SRC python :tangle format.py :eval no
    newYmlFile = open(outputFile, "w")

    for lines in newYmlData:
        newYmlFile.write(lines)
#+END_SRC

**** Close file pointers
#+BEGIN_SRC python :tangle format.py :eval no
    newYmlFile.close()
#+END_SRC

**** Return function call
#+BEGIN_SRC python :tangle format.py :eval no
    return
#+END_SRC
*** Registering reverseproxy and awstats Entries
Reverseproxy entries of the labs are to be made in order for the labs to be
accessible from external world. Domain values are read from the data file and
appended to reverseproxy "yaml" file.

**** Function definition
#+BEGIN_SRC python :tangle format.py :eval no
def reverseproxy(inputFile, outputFile):
#+END_SRC

**** Open Input File and Output File
Open input file - "lab.txt" to read the content. Also open output file -
"private_dns.yaml" to write data.
#+BEGIN_SRC python :tangle format.py :eval no 
    labFile = open(inputFile, "r")
    ymlFile = open(outputFile, "r")
#+END_SRC

**** Read yml file
Read yml file line by line and save data in a variable.
#+BEGIN_SRC python :tangle format.py :eval no
    ymlData = ymlFile.readlines()
#+END_SRC

**** Find start and end index of markers
Find the start and end index of the markers in the yml file.
#+BEGIN_SRC python :tangle format.py :eval no
    domainStartIndex = ymlData.index("#DOMAIN_START\n")
    domainEndIndex = ymlData.index("#DOMAIN_END\n")

    awstatsStartIndex = ymlData.index("#AWSTATS_START\n")
    awstatsEndIndex = ymlData.index("#AWSTATS_END\n")
#+END_SRC	

**** Save existing entries in a variable
Data is in between the markers, so entries are fetched from file and saved in a
variable.
#+BEGIN_SRC python :tangle format.py :eval no
    domainExistingEntries = []
    awstatsExistingEntries = []

    for index in range(domainStartIndex + 2, domainEndIndex):
        domainExistingEntries.append(ymlData[index])
    
    for index in range(awstatsStartIndex + 2, awstatsEndIndex):
        awstatsExistingEntries.append(ymlData[index])
#+END_SRC		

**** Save new entries in the variable
New entries are appended in the same variable with proper format.

#+BEGIN_SRC python :tangle format.py :eval no
    domainNewEntries = []
    awstatsNewEntries = []
	
    for line in labFile.readlines():
        splitLine = line.split()
	fqdn = splitLine[0] + ".virtual-labs.ac.in"
	alias = splitLine[0] + ".vlabs.ac.in"
	hostnameAndIP = '  - {domain: "%s", alias: "%s" }\n' %(fqdn, alias)
	awstats = '  - %s\n' %(fqdn)

	domainNewEntries.append(hostnameAndIP)
	awstatsNewEntries.append(awstats)
#+END_SRC

**** Combine existing and new entries in a variable
#+BEGIN_SRC python :tangle format.py :eval no
    domainTotalEntries = domainExistingEntries + domainNewEntries    
    awstatsTotalEntries = awstatsExistingEntries + awstatsNewEntries
#+END_SRC

**** Remove duplicate entries
Remove duplicates by converting list into set first and then again into list.
#+BEGIN_SRC python :tangle format.py :eval no
    domainTotalEntries = list(set(domainTotalEntries))
    awstatsTotalEntries = list(set(awstatsTotalEntries))
#+END_SRC

**** Complete file content
#+BEGIN_SRC python :tangle format.py :eval no
    delimeter = list("#DOMAIN_END\n\n#AWSTATS_START\nawstats_domains:\n")
    newYmlData = ymlData[0:domainStartIndex + 1] + domainTotalEntries + delimeter + awstatsTotalEntries + ymlData[awstatsEndIndex:-1]
#+END_SRC

**** Close file pointers
#+BEGIN_SRC python :tangle format.py :eval no
    labFile.close()
    ymlFile.close()
#+END_SRC

**** Write complete data to a file
Data is written to a file line by line.
#+BEGIN_SRC python :tangle format.py :eval no
    newYmlFile = open(outputFile, "w")

    for lines in newYmlData:
        newYmlFile.write(lines)
#+END_SRC

**** Close file pointers
#+BEGIN_SRC python :tangle format.py :eval no
    newYmlFile.close()
#+END_SRC

**** Return function call
#+BEGIN_SRC python :tangle format.py :eval no
    return
#+END_SRC
*** Main Function
#+BEGIN_SRC python :tangle format.py :eval no
def main():

    option = raw_input("Which role you wish to modify (pubdns, privdns, rp, nagios) ?")

    if (option == "pubdns"):
        dns("lab.txt", "main.yml")
    elif (option == "privdns"):
        dns("lab.txt", "main.yml")
    elif (option == "rp"):
        reverseproxy("lab.txt", "main.yml")
    elif (option == "nagios"):
        nagios()


if __name__ == "__main__":
   main()
#+END_SRC

* Test Cases
** Test case ID :: SSH access using AWS KeyPair
*** Objective
    Test to check if SSH is allowed only from IIIT network for the user
    root and denied from other ips using AWS KeyPair
*** Apparatus
    1. Security KeyPair
    2. A workstation with IIIT ips 
    3. A workstation with unknown ip 
    4. Configuration server 
*** Procedure
    1. Assume you are inside the IIIT network.
    2. Create a VM and generate new security KeyPair using AWS console
    3. Place/copy the KeyPair into ssh-tunnel container.
    4. Give 400 permission to that KeyPair and
    5. ssh to config_server from workstation 
*** Experiments
**** SSH to the config_server from management ips/ IIIT ips
    Since configuration server is created using AWS console, KeyPair
    of this server is generated during creation of the VM. So the
    private KeyPair is placed in "ssh-tunnel" container on base2. From
    "ssh-tunnel", only VLEAD members (who have ssh access to
    ssh-tunnel and sudo permissions to root account) can ssh to
    configuration server only from IIIT network.  ssh to configuration
    server using the below command:
    #+BEGIN_SRC example
    ssh -i test.pem root@54.56.34.231
    #+END_SRC
***** Expected result
   #+BEGIN_EXAMPLE
    Last login: ---Details of last login---
    [root@localhost ~]$
   #+END_EXAMPLE
***** Result
    #+BEGIN_EXAMPLE
    Last login: Mon Mar 16 02:28:31 2015 from ssh-tunnel.vlabs.ac.in
    [root@config-server~]$
    #+END_EXAMPLE
**** SSH to config_server from workstation with unknown ip
    Suppose a workstation with unknown ip(other than IIIT network ip)
    and it has KeyPair, then try ssh to configuration server from that
    workstation using bellow command:

    #+BEGIN_SRC example 
    unknown-machine$ ssh -i test.pem root@54.56.34.231
    #+END_SRC
***** Result
    #+BEGIN_SRC example
    Permission denied....
    #+END_SRC
*** Observation 
    Configuration server is able accept ssh connection only from
    IIIT/management ips and not from any other machines with unknown
    ips.
*** Result 
    Test is passed. Firewall rules and ssh are configured and applied
    properly. 
*** Conclusion
  Iptables and ssh are configured and applied appropriately. Configuration
  server is able accept ssh connections only from IIIT/management IPs and
  not from unknown ips.

** Test case ID :: SSH access using RSA key
*** Objective
    Test to check if SSH is allowed only from IIIT network for the user
    root and denied from other ips using workstation's RSA key
*** Apparatus
    1. RSA key
    2. A workstation1 with IIIT ips 
    3. A workstation2 with unknown ip 
    4. Configuration server 
*** Procedure
    1. Assume you are inside the IIIT network.
    2. Create a container and generate ssh key using the following command
       #+BEGIN_SRC example
       ssh-keygen -t rsa 
       #+END_SRC
       Provide the passphrase if you need. Else press RETURN for no passphrase.
    3. Place/copy the id_rsa.pub of workstation into configuration
       server's authorized_keys.
    4. SSH to configuration server from workstation.
*** Experiments
**** SSH to the config_server from IIIT ips/management ips
    From "workstation1", only VLEAD members (who have ssh access to
    workstation and sudo permissions to root account) can ssh to
    configuration server only from IIIT network.  ssh to configuration
    server using the bellow command:
    #+BEGIN_SRC example
    workstation1$ssh root@54.56.34.231
    #+END_SRC
***** Expected result
   #+BEGIN_EXAMPLE
    Last login: ---Details of last login---
    [root@localhost ~]$
   #+END_EXAMPLE
***** Result
    #+BEGIN_EXAMPLE
    Last login: Mon Mar 16 02:28:31 2015 from workstation1
    [root@config-server~]$
    #+END_EXAMPLE
**** SSH to config_server from workstation2 with unknown ip
    ssh to configuration server from workstation2 which has unknown
    ip(other than IIIT network ip) using bellow command
    #+BEGIN_SRC example 
    workstation2$ ssh root@54.56.34.231
    #+END_SRC
***** Result
    #+BEGIN_SRC example
    Permission denied....
    #+END_SRC
*** Observation 
    Configuration server is able to accept ssh connection only from
    IIIT/management ips and not from any other machines with
    unknown ips.
*** Result
    Test is passed. configuration is working fine
*** Conclusion
  Iptables are configured and applied appropriately. Configuration
  server is able accept ssh connections only from IIIT/management IPs
  and not from unknown ips.
* COMMENT TODO
** Write a tasks in playbook to place the code in proper directory, set PATH environment variable.
** Separate out the lab entries from the node models. Because in future ads
   will be registering new labs and making changes directly to implementation
   files and those entries could not be updated in the model. So it is better
   to separate out lab entries. Instead we can have only system services
   entries in the model and lab entries could be directly added by ads hooks in
   the implementation files. And playbook collate these entries from two files
   and set the node. 
** DONE Put hooks diagram in the config-server.org
** DONE Create two section in the design one is services and another is configuration.
** DONE Add section for this implementation of the above requirements in the config-server.org. 
** DONE Add requirements of registering and de-registering labs in the config server.
** DONE First make the scripts. 
** DONE Write a separate section with code and logic of registering labs in the  config-server.org.
** DONE Requirements of the hooks::
   - A SSH call from ads server to register.sh script.
   - register.sh then writes data into lab.txt
   - then invokes python program to convert lab.txt into a separate file.
   - Collate entries from models and newly generated file and provide it to
     playbook.
   - then invoke the playbook of setting up server again with updated entries
     or directly call site.yml.
* COMMENT QA Review
1. DR process provided by amazon.
2. Code for the recovering the problems.
3. Test cases from tester and integration engineer. 
4. What is the load on the server.
